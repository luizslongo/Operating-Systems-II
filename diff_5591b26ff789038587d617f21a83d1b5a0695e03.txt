diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 000000000..a61880a28
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,15 @@
+FROM fedora:40
+
+RUN --mount=type=cache,target=/var/cache/dnf dnf install -y \
+        dev86 \
+        gcc-c++-x86_64-linux-gnu \
+        gcc-x86_64-linux-gnu \
+        binutils-x86_64-linux-gnu \
+        qemu-system-x86 \
+        make \
+        g++ \
+        gcc \
+        fish \
+        git
+
+WORKDIR /build
diff --git a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
index 68dbb0976..b2a75accd 100644
--- a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
+++ b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
@@ -1,6 +1,7 @@
 #ifndef __traits_h
 #define __traits_h
 
+#include "system/traits.h"
 #include <system/config.h>
 
 __BEGIN_SYS
@@ -10,25 +11,27 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int SMOD = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
-    static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = 1;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 4 : 1;
     static const unsigned int NETWORKING = STANDALONE;
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool trace = false;
+    static const bool monitored = true;
+    static const bool hysterically_debugged = true;
 };
 
 
 // Utilities
 template<> struct Traits<Debug>: public Traits<Build>
 {
-    static const bool error   = true;
-    static const bool warning = true;
+    static const bool error   = false;
+    static const bool warning = false;
     static const bool info    = false;
     static const bool trace   = false;
 };
@@ -117,8 +120,9 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool smp = Traits<System>::multicore;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
+    static const int priority_inversion_protocol = INHERITANCE;
 
-    typedef IF<(CPUS > 1), GRR, RR>::Result Criterion;
+    typedef IF<(CPUS > 1), GEDF_Modified, GEDF_Modified>::Result Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/hello/hello.cc b/app/hello/hello.cc
index 40c7c05c2..8a2989d35 100644
--- a/app/hello/hello.cc
+++ b/app/hello/hello.cc
@@ -1,12 +1,71 @@
 #include <utility/ostream.h>
+#include <real-time.h>
+#include <architecture/cpu.h>
+#include <scheduler.h>
 
 using namespace EPOS;
 
 OStream cout;
 
-int main()
-{
-    cout << "Hello world!" << endl;
+const unsigned int iterations = 10;
+const Milisecond period_a = 100;
+const Milisecond period_b = 80;
+const Milisecond period_c = 167;
+const Milisecond wcet_a = 50;
+const Milisecond wcet_b = 20;
+const Milisecond wcet_c = 60;
+
 
+int my_func(char id, int limit) {
+    do {
+    long long b = 0;
+    for (int i = 0; i < limit; ++i) {
+       b += i - i/3;
+    }
+    OStream cout;
+    cout << "Finished Iteration: " << id << '\n';
+    } while (Periodic_Thread::wait_next());
+    
+    return 0;
+}
+int my_func_aperiodic(char id) {
+    long long b = 0;
+    for (int i = 0; i < 1e1; ++i) {
+       b += i - i/3;
+    }
+    OStream cout;
+    cout << b << '\n';
+    
     return 0;
 }
+
+int main()
+{   //                                       p,               d, c,             act, t
+    // thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, wcet_a * 1000,   0, iterations), &func_a);
+    // thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, wcet_b * 1000,   0, iterations), &func_b);
+    // thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, wcet_c * 1000,   0, iterations), &func_c);
+    /*
+    const unsigned int iterations = 100;
+    const Milisecond period_a = 100;
+    const Milisecond period_b = 80;
+    const Milisecond period_c = 60;
+    const Milisecond wcet_a = 50;
+    const Milisecond wcet_b = 20;
+    const Milisecond wcet_c = 10;
+    */
+    //                                              p              , d              , c            , a, n         , task_type
+    Periodic_Thread* a = new Periodic_Thread(RTConf(period_a * 1000, period_a * 1000, wcet_a * 1000, 0, iterations, EDF_Modified::CRITICAL)   , &my_func, 'A', (int)1e6);
+    Periodic_Thread* b = new Periodic_Thread(RTConf(period_b * 1000, period_b * 1000, wcet_b * 1000, 0, iterations, EDF_Modified::BEST_EFFORT), &my_func, 'B', (int)1e7);
+    Periodic_Thread* c = new Periodic_Thread(RTConf(period_c * 1000, period_c * 1000, wcet_a * 1000, 0, iterations, EDF_Modified::CRITICAL)   , &my_func, 'C', (int)2.5e7);
+    Thread* d = new Thread(&my_func_aperiodic, 'D');
+    
+    cout << "A: " << a << " B: " << b << " C: " << c << " D: " << d << endl;
+    // cout << "B: " << b << " D: " << d << endl;
+
+    a->join();
+    b->join();
+    c->join();
+    d->join();
+    
+    return 0;
+}
\ No newline at end of file
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 01a846308..96719ad72 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -13,23 +13,24 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const unsigned int ARCHITECTURE = IA32;
     static const unsigned int MACHINE = PC;
     static const unsigned int MODEL = Legacy_PC;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
+    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 4 : 1;
     static const unsigned int NETWORKING = STANDALONE;
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = true;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool trace = false;
+    static const bool monitored = true;
+    static const bool hysterically_debugged = true;
 };
 
 
 // Utilities
 template<> struct Traits<Debug>: public Traits<Build>
 {
-    static const bool error   = true;
-    static const bool warning = true;
+    static const bool error   = false;
+    static const bool warning = false;
     static const bool info    = false;
     static const bool trace   = false;
 };
@@ -118,10 +119,9 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool smp = Traits<System>::multicore;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
-    static const int priority_inversion_protocol = NONE;
-
+    static const int priority_inversion_protocol = INHERITANCE;
 
-    typedef IF<(CPUS > 1), Fixed_CPU, Priority>::Result Criterion;
+    typedef IF<(CPUS > 1), GEDF_Modified, EDF_Modified>::Result Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/include/architecture/ia32/ia32_cpu.h b/include/architecture/ia32/ia32_cpu.h
index 684c90c65..20b956bcb 100644
--- a/include/architecture/ia32/ia32_cpu.h
+++ b/include/architecture/ia32/ia32_cpu.h
@@ -352,20 +352,23 @@ public:
 
     static volatile unsigned int id();
     static unsigned int cores() { return multicore ? _cores : 1; }
+    static void cores(unsigned int cores) {
+        _cores = cores;
+    }
 
     static Hertz clock() { return _cpu_current_clock; }
     static void clock(Hertz frequency) {
         Reg64 clock = frequency;
         unsigned int dc;
-        if(clock <= (_cpu_clock * 1875 / 10000)) {
+        if(clock <= (_cpu_clock * 1875ULL / 10000ULL)) {
             dc = 0b10011;   // minimum duty cycle of 12.5 %
-            _cpu_current_clock = _cpu_clock * 1875 / 10000;
-        } else if(clock >= (_cpu_clock * 9375 / 10000)) {
+            _cpu_current_clock = _cpu_clock * 1875ULL / 10000ULL;
+        } else if(clock >= (_cpu_clock * 9375ULL / 10000ULL)) {
             dc = 0b01001;   // disable duty cycling and operate at full speed
             _cpu_current_clock = _cpu_clock;
         } else {
-            dc = 0b10001 | ((clock * 10000 / _cpu_clock + 625) / 625); // dividing by 625 instead of 1250 eliminates the shift left
-            _cpu_current_clock = _cpu_clock * ((clock * 10000 / _cpu_clock + 625) / 625) * 625 / 10000;
+            dc = 0b10001 | ((clock * 10000ULL / _cpu_clock + 625ULL) / 625ULL); // dividing by 625 instead of 1250 eliminates the shift left
+            _cpu_current_clock = _cpu_clock * ((clock * 10000ULL / _cpu_clock + 625ULL) / 625ULL) * 625ULL / 10000ULL;
             // The ((clock * 10000 / _cpu_clock + 625) / 625) returns the factor, the step is 625/10000
             // thus, max_clock * factor * step = final clock
         }
@@ -411,7 +414,7 @@ public:
 
     template<typename T>
     static T cas(volatile T & value, T compare, T replacement) {
-        ASM("lock cmpxchgl %2, %3\n" : "=a"(compare) : "a"(compare), "r"(replacement), "m"(value) : "memory");
+        ASM("lock cmpxchg %2, %3\n" : "=a"(compare) : "a"(compare), "r"(replacement), "m"(value) : "memory");
         return compare;
     }
 
@@ -597,7 +600,9 @@ private:
     }
     static void init_stack_helper(Log_Addr sp) {}
 
+public:
     static void smp_barrier_init(unsigned int cores);
+private:
     static void init();
 
 private:
diff --git a/include/process.h b/include/process.h
index 9ae7dc7b0..2add45e37 100644
--- a/include/process.h
+++ b/include/process.h
@@ -55,7 +55,10 @@ public:
         NORMAL  = Criterion::NORMAL,
         LOW     = Criterion::LOW,
         MAIN    = Criterion::MAIN,
-        IDLE    = Criterion::IDLE
+        IDLE    = Criterion::IDLE,
+        PHIGH   = Criterion::PHIGH,
+        PNORMAL = Criterion::PNORMAL,
+        PLOW    = Criterion::PLOW
     };
 
     // Thread Queue
diff --git a/include/real-time.h b/include/real-time.h
index fd8e7510e..5fd7eb206 100644
--- a/include/real-time.h
+++ b/include/real-time.h
@@ -61,8 +61,8 @@ protected:
 
 public:
     struct Configuration: public Thread::Configuration {
-        Configuration(Microsecond p, Microsecond d = SAME, Microsecond c = UNKNOWN, Microsecond a = NOW, const unsigned int n = INFINITE, State s = READY, unsigned int ss = STACK_SIZE)
-        : Thread::Configuration(s, Criterion(p, d, c), ss), activation(a), times(n) {}
+        Configuration(Microsecond p, Microsecond d = SAME, Microsecond c = UNKNOWN, Microsecond a = NOW, const unsigned int n = INFINITE, int task_type = 0, State s = READY, unsigned int ss = STACK_SIZE)
+        : Thread::Configuration(s, Criterion(p, d, c, task_type), ss), activation(a), times(n) {}
 
         Microsecond activation;
         unsigned int times;
@@ -114,8 +114,8 @@ protected:
 class RT_Thread: public Periodic_Thread
 {
 public:
-    RT_Thread(void (* function)(), Microsecond p, Microsecond d = SAME, Microsecond c = UNKNOWN, Microsecond a = NOW, int n = INFINITE, unsigned int ss = STACK_SIZE)
-    : Periodic_Thread(Configuration(p, d, c, a, n, SUSPENDED, ss), &entry, this, function, a, n) {
+    RT_Thread(void (* function)(), Microsecond p, Microsecond d = SAME, Microsecond c = UNKNOWN, Microsecond a = NOW, int n = INFINITE, int task_type = 0, unsigned int ss = STACK_SIZE)
+    : Periodic_Thread(Configuration(p, d, c, a, n, task_type, SUSPENDED, ss), &entry, this, function, a, n) {
         resume();
     }
 
diff --git a/include/scheduler.h b/include/scheduler.h
index fea2c9dda..3b6267ac9 100644
--- a/include/scheduler.h
+++ b/include/scheduler.h
@@ -9,6 +9,8 @@
 #include <utility/scheduling.h>
 #include <utility/math.h>
 #include <utility/convert.h>
+#include <system/traits.h>
+#include <system.h>
 
 __BEGIN_SYS
 
@@ -25,16 +27,39 @@ protected:
     typedef Timer_Common::Tick Tick;
 
 public:
-    // Priorities
+    /*
+       // NOTE: Also, make sure MSB is 0.
+        APERIODIC_BIT --> 010000000000000
+        PERIODIC_BIT  --> 000000000000000
+
+        IDLE          --> 011100000000000
+        LOW           --> 011000000000000
+        NORMAL        --> 010100000000000
+        HIGH          --> 010000000000000
+        PLOW          --> 001100000000000
+        PNORMAL       --> 001000000000000
+        PHIGH         --> 000000000000000
+        MAIN          --> 111111111111100
+    
+    */
+    // Aperiodics Threads Priorities
     enum : int {
         CEILING = -1000,
         MAIN    = -1,
-        HIGH    = 0,
-        NORMAL  = (unsigned(1) << (sizeof(int) * 8 - 3)) - 1,
-        LOW     = (unsigned(1) << (sizeof(int) * 8 - 2)) - 1,
-        IDLE    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
+        HIGH    = (unsigned(0b100) << (sizeof(int) * 8 - 4)),
+        NORMAL  = (unsigned(0b101) << (sizeof(int) * 8 - 4)),
+        LOW     = (unsigned(0b110) << (sizeof(int) * 8 - 4)),
+        IDLE    = (unsigned(0b111) << (sizeof(int) * 8 - 4)),
     };
 
+    // Periodics Threads Priorities
+    enum : int {
+        PHIGH    = 0,
+        PNORMAL  = (unsigned(0b010) << (sizeof(int) * 8 - 4)),
+        PLOW     = (unsigned(0b011) << (sizeof(int) * 8 - 4))
+    };
+
+
     // Constructor helpers
     enum : unsigned int {
         SAME        = 0,
@@ -45,11 +70,17 @@ public:
 
     // Policy types
     enum : int {
-        PERIODIC    = HIGH,
-        SPORADIC    = NORMAL,
+        PERIODIC    = PHIGH,
+        SPORADIC    = PLOW,
         APERIODIC   = LOW
     };
 
+    // Task types
+    enum : int {
+        CRITICAL    = PHIGH,
+        BEST_EFFORT = PNORMAL
+    };
+
     // Policy events
     typedef int Event;
     enum {
@@ -91,8 +122,11 @@ public:
         Tick job_start;                         // tick in which the last job of a periodic thread started (different from "thread_last_dispatch" since jobs can be preempted)
         Tick job_finish;                        // tick in which the last job of a periodic thread finished (i.e. called _alarm->p() at wait_netxt(); different from "thread_last_preemption" since jobs can be preempted)
         Tick job_utilization;                   // accumulated execution time (in ticks)
+        unsigned int average_job_execution_time;// average execution time of the last 5 jobs.
+        unsigned int number_dispatches;         // number of dispatches that thread did
         unsigned int jobs_released;             // number of jobs of a thread that were released so far (i.e. the number of times _alarm->v() was called by the Alarm::handler())
         unsigned int jobs_finished;             // number of jobs of a thread that finished execution so far (i.e. the number of times alarm->p() was called at wait_next())
+
     };
 
     struct Real_Statistics {  // for Traits<System>::monitored = true
@@ -109,11 +143,13 @@ public:
         Tick job_start;                         // tick in which the last job of a periodic thread started (different from "thread_last_dispatch" since jobs can be preempted)
         Tick job_finish;                        // tick in which the last job of a periodic thread finished (i.e. called _alarm->p() at wait_netxt(); different from "thread_last_preemption" since jobs can be preempted)
         Tick job_utilization;                   // accumulated execution time (in ticks)
+        unsigned int average_job_execution_time;// average execution time of the last 5 jobs.
+        unsigned int number_dispatches;         // number of dispatches that thread did
         unsigned int jobs_released;             // number of jobs of a thread that were released so far (i.e. the number of times _alarm->v() was called by the Alarm::handler())
         unsigned int jobs_finished;             // number of jobs of a thread that finished execution so far (i.e. the number of times alarm->p() was called at wait_next())
     };
 
-    typedef IF<Traits<System>::monitored, Real_Statistics, Dummy_Statistics>::Result Statistics;
+    typedef IF<Traits<Thread>::monitored, Real_Statistics, Dummy_Statistics>::Result Statistics;
 
 protected:
     Scheduling_Criterion_Common() {}
@@ -333,7 +369,6 @@ public:
     void handle(Event event);
 };
 
-
 // Least Laxity First
 class LLF: public RT_Common
 {
@@ -347,6 +382,41 @@ public:
     void handle(Event event);
 };
 
+// Earliest Deadline First Modified
+class EDF_Modified: public RT_Common
+{
+public:
+    static const bool dynamic = true;
+public:
+    EDF_Modified(int p = APERIODIC): RT_Common(p), _min_frequency(CPU::max_clock()), _max_frequency(CPU::max_clock()), _last_deadline(0), _step(-1) {}
+    EDF_Modified(Microsecond p, Microsecond d, Microsecond c, int task_type = CRITICAL);
+
+    void handle(Event event);
+private:
+    void _handle_charge(Event event);
+    void _calculate_min_frequency();
+    
+    Hertz _min_frequency;
+    Hertz _max_frequency;
+    int _last_deadline;
+    Hertz _step;
+};
+
+// Global EDF_Modified
+class GEDF_Modified: public EDF_Modified
+{
+public:
+    static const unsigned int HEADS = Traits<Machine>::CPUS;
+
+public:
+    template <typename ... Tn>
+    GEDF_Modified(int p = APERIODIC, Tn & ... an): EDF_Modified(p) {}
+    template <typename ... Tn>
+    GEDF_Modified(Microsecond p, Microsecond d, Microsecond c, int task_type = CRITICAL, Tn & ... an): EDF_Modified(p,d,c,task_type) {}
+    
+    static unsigned int current_head() { return CPU::id(); }
+};
+
 __END_SYS
 
 __BEGIN_UTIL
@@ -356,6 +426,10 @@ template<typename T>
 class Scheduling_Queue<T, GRR>:
 public Multihead_Scheduling_List<T> {};
 
+template<typename T>
+class Scheduling_Queue<T, GEDF_Modified>:
+public Multihead_Scheduling_List<T> {};
+
 template<typename T>
 class Scheduling_Queue<T, Fixed_CPU>:
 public Scheduling_Multilist<T> {};
diff --git a/include/system/traits.h b/include/system/traits.h
index 8e7d12cc8..268a35767 100644
--- a/include/system/traits.h
+++ b/include/system/traits.h
@@ -112,6 +112,8 @@ class DM;
 class LM;
 class EDF;
 class LLF;
+class EDF_Modified;
+class GEDF_Modified;
 class GRR;
 class Fixed_CPU;
 class CPU_Affinity;
diff --git a/include/utility/list.h b/include/utility/list.h
index 1a7107cf0..c1a69fb68 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -14,7 +14,11 @@ public:
     List_Element_Rank(int r = 0): _rank(r) {}
 
     operator int() const { return _rank; }
-
+    
+    List_Element_Rank& operator+=(const List_Element_Rank& other) {
+        _rank += other._rank;
+        return *this;
+    }
 protected:
     int _rank;
 };
diff --git a/makefile b/makefile
index 1f9dbcba7..6d35aad20 100644
--- a/makefile
+++ b/makefile
@@ -50,7 +50,7 @@ TEE             = tee
 ifndef DISPLAY
 TERM            = sh -c
 else
-TERM            = konsole -e
+TERM            = alacritty -e
 endif
 TOUCH           = touch
 
diff --git a/run-docker.sh b/run-docker.sh
new file mode 100755
index 000000000..e71342149
--- /dev/null
+++ b/run-docker.sh
@@ -0,0 +1,19 @@
+#!/usr/bin/env bash
+
+if [ -z "$(docker images -q ine5424:latest 2> /dev/null)" ]; then
+        cmd="docker build -t ine5424 ."
+        echo "running $cmd"
+        eval "$cmd"
+fi
+
+args=
+
+if [ "$#" -gt 0 ]; then
+        args="$@"
+else
+        args="/bin/fish"
+fi
+
+cmd="docker run -ti --rm --name ine5424  --mount=type=bind,src=$(pwd),target=/build ine5424 $args"
+echo "running $cmd"
+eval "$cmd"
diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
index 376f77b27..2ca9c10a4 100644
--- a/src/api/scheduler.cc
+++ b/src/api/scheduler.cc
@@ -7,6 +7,270 @@ __BEGIN_SYS
 
 volatile unsigned int Variable_Queue_Scheduler::_next_queue;
 
+inline RT_Common::Tick RT_Common::elapsed() { return Alarm::elapsed(); }
+
+RT_Common::Tick RT_Common::ticks(Microsecond time) {
+    return Timer_Common::ticks(time, Alarm::timer()->frequency());
+}
+
+Microsecond RT_Common::time(Tick ticks) {
+    return Timer_Common::time(ticks, Alarm::timer()->frequency());
+}
+
+void RT_Common::handle(Event event) {
+    db<Thread>(TRC) << "RT::handle(this=" << this << ",e=";
+    if(event & CREATE) {
+        db<Thread>(TRC) << "CREATE";
+
+        _statistics.thread_creation = elapsed();
+        _statistics.job_released = false;
+    }
+    if(event & FINISH) {
+        db<Thread>(TRC) << "FINISH";
+
+        _statistics.thread_destruction = elapsed();
+    }
+    if(event & ENTER) {
+        db<Thread>(TRC) << "ENTER";
+
+        _statistics.thread_last_dispatch = elapsed();
+        _statistics.number_dispatches++;
+    }
+    if(event & LEAVE) {
+        Tick cpu_time = elapsed() - _statistics.thread_last_dispatch;
+
+        db<Thread>(TRC) << "LEAVE";
+
+        _statistics.thread_last_preemption = elapsed();
+        _statistics.thread_execution_time += cpu_time;
+        _statistics.job_utilization += cpu_time;
+//        if(_statistics.job_released) {
+//        }
+    }
+    if(periodic() && (event & JOB_RELEASE)) {
+        db<Thread>(TRC) << "RELEASE";
+
+        if (_statistics.jobs_released < 5)
+            _statistics.average_job_execution_time += _statistics.job_utilization/5;
+        else {
+            _statistics.average_job_execution_time = (_statistics.average_job_execution_time*4 + _statistics.job_utilization)/5;
+        }
+        
+        OStream cout;
+        cout << "JOB AVERAGE EXECUTION TIME (last 5 executions): " << _statistics.average_job_execution_time << '\n';
+        cout << "JOB UTILIZATION: " << _statistics.job_utilization << '\n';
+        _statistics.job_released = true;
+        _statistics.job_release = elapsed();
+        _statistics.job_start = 0;
+        _statistics.job_utilization = 0;
+        _statistics.jobs_released++;
+    }
+    if(periodic() && (event & JOB_FINISH)) {
+        db<Thread>(TRC) << "WAIT";
+
+        _statistics.job_released = false;
+        _statistics.job_finish = elapsed();
+        _statistics.jobs_finished++;
+//        _statistics.job_utilization += elapsed() - _statistics.thread_last_dispatch;
+    }
+    if(event & COLLECT) {
+        db<Thread>(TRC) << "|COLLECT";
+    }
+    if(periodic() && (event & CHARGE)) {
+        db<Thread>(TRC) << "|CHARGE";
+    }
+    if(periodic() && (event & AWARD)) {
+        db<Thread>(TRC) << "|AWARD";
+    }
+    if(periodic() && (event & UPDATE)) {
+        db<Thread>(TRC) << "|UPDATE";
+    }
+    db<Thread>(TRC) << ") => {i=" << _priority << ",p=" << _period << ",d=" << _deadline << ",c=" << _capacity << "}" << endl;
+}
+
+
+EDF_Modified::EDF_Modified(Microsecond p, Microsecond d, Microsecond c, int task_type): RT_Common(int(elapsed() + ticks(d)) | task_type, p, d, c), _min_frequency(CPU::max_clock()), _max_frequency(CPU::max_clock()), _last_deadline(elapsed()), _step(_max_frequency ) {
+    memset(&_statistics, 0, sizeof(_statistics));
+    // _statistics.thread_last_dispatch = _statistics.thread_last_preemption = _statistics.jobs_released = _statistics.job_utilization = _statistics.average_job_execution_time = 0;
+}
+
+void EDF_Modified::_calculate_min_frequency() {
+    if (_statistics.jobs_released < 5)
+        return;
+
+    unsigned int average_execution_fraction = (_statistics.average_job_execution_time * 10)/_deadline;
+    
+    OStream cout;
+    cout << "AVERAGE EF: " << average_execution_fraction << ", _DEADLINE: " << _deadline << '\n';
+
+    if (_statistics.jobs_released == 5) {
+        Hertz step = (CPU::max_clock() - CPU::min_clock())/10;
+        _min_frequency = CPU::min_clock() + step*average_execution_fraction;
+        return;
+    }
+    // fazemos dessa forma pra ter uma mudança mais previsível no min_cpu_frequency. 
+    // Pensei em fazer matematicamente, mas n achei nenhuma forma boa.
+    switch (average_execution_fraction) {
+        case 0:
+        case 1:
+            _min_frequency -= _min_frequency/4; //diminui 25%
+            break; //entre 0% e 20%
+        case 2:
+        case 3:
+            _min_frequency -= _min_frequency/8; //diminui 12.5%
+            break; //entre 20% e 40%
+        case 4:
+        case 5:
+        case 6:
+            break; //entre 40% e 70% 
+        case 7:
+        case 8:
+            _min_frequency += _min_frequency/8; //aumenta 12.5%
+            break; //entre 70% e 90%
+        default:
+            _min_frequency += _min_frequency/4; //aumenta 25%
+            //acima de 90%
+        
+    }
+
+    //Resolvendo problemas de contorno
+    if (_min_frequency < CPU::min_clock())
+        _min_frequency = CPU::min_clock();
+    else if (_min_frequency > CPU::max_clock())
+        _min_frequency = CPU::max_clock();
+}
+
+void EDF_Modified::_handle_charge(Event event) {
+    EPOS::OStream cout;
+    if (!periodic()) {
+        if (CPU::clock() != _max_frequency) {
+            cout << "Aperiodic Task!!! Putting CPU on MAX FREQUENCY\n";
+            CPU::clock(_max_frequency);
+        }
+        return;
+    }
+
+    unsigned int task_type = ((BEST_EFFORT & _priority) == BEST_EFFORT ? BEST_EFFORT : CRITICAL);
+
+    if (_statistics.number_dispatches % (task_type == BEST_EFFORT ? 10 : 3) != 0) {
+        cout << "\n========================================================\n";
+        cout << "NUMBER OF DISPATCHES NOT ENOUGH TO RECALCULATE FREQUENCY\n";
+        cout << "TASK TYPE: " << (task_type == BEST_EFFORT ? "BEST_EFFORT" : "CRITICAL") << "\n";
+        cout << "NUMBER DISPATCHES = " << _statistics.number_dispatches << "\n";
+        cout << "CPU MAX FREQ: " << CPU::max_clock() << "\n";
+        cout << "CPU MIN FREQ: " << CPU::min_clock() << "\n";
+        cout << "CPU FREQ: " << CPU::clock() << "\n";
+        cout << "\n========================================================\n";
+        return;
+    }
+    
+    unsigned int absolute_deadline = _priority - task_type;
+    unsigned int start_time = _last_deadline;
+    unsigned int current_time = elapsed();
+    
+    if (current_time > absolute_deadline) {
+        cout << "\n========================================================\n";
+        cout << "Deadline Missed!!! Putting CPU on MAX FREQUENCY\n";
+        cout << "CURRENT: " << current_time << ", START: " << start_time << ", AB DL: " << absolute_deadline << "\n";
+        cout << "\n========================================================\n";
+        CPU::clock(_max_frequency);
+        return;
+    }
+    
+    unsigned int slack = (absolute_deadline - current_time)*10;
+    unsigned int relative_deadline = absolute_deadline - start_time;
+    
+    unsigned int time_fraction = 10 - slack / relative_deadline;
+
+    /*
+    Intel has 8 frequency levels.
+    
+    They probably are based on multiples of 12.5, so:
+    Level 1 = 12.5% of frequency range
+    Level 2 = 25.0% of frequency range
+    ...
+    and so on.
+
+    For values of time_fraction:
+        < 10% --> level 1
+        < 20% --> level 2
+        < 30% --> level 2
+        < 40% --> level 3
+        < 50% --> level 5
+        < 60% --> level 6
+        < 70% --> level 7
+        < 80% -> level 7
+        >= 80% -> level 8
+    */
+    int level;
+    switch (time_fraction) {
+        case 0: // < 10%
+            level = 1;
+            break;
+        case 1: // < 20%
+            level = 2;
+            break;
+        case 2: // < 30%
+            level = 2;
+            break;
+        case 3: // < 40%
+            level = 3;
+            break;
+        case 4: // < 50%
+            level = 5;
+            break;
+        case 5: // < 60%
+            level = 6;
+            break;
+        case 6: // < %70
+            level = 7;
+            break;
+        case 7: // < 80%
+            level = 7;
+            break;
+        default: // >= %80
+            level = 8;
+            
+    }
+    
+    Hertz delta = _max_frequency - _min_frequency;
+    _step = delta % 8 == 0 ? delta/8 : delta/8 + 1;
+
+    Hertz frequency = _min_frequency + level*_step;
+    if (frequency > CPU::max_clock())
+        frequency = CPU::max_clock();
+
+    CPU::clock(frequency);
+    cout << "\n========================================================\n";
+    cout << "CURRENT: " << current_time << ", START: " << start_time << ", AB DL: " << absolute_deadline << "\n";
+    cout << "TF: " << time_fraction << ", SLACK: " << slack << ", REAL DL: " << relative_deadline << "\n";
+    cout << "LEVEL: " << level << ", step: " << _step << ", CLOCK: " << frequency << ", MIN FREQ: " << _min_frequency << "\n";
+    cout << "MAX FREQ: " << CPU::max_clock() << "\n";
+    cout << "NEW FREQ: " << CPU::clock() << "\n";
+    cout << "FREQ PERCENTAGE: " << ((frequency - CPU::min_clock())*100.0)/(CPU::max_clock() - CPU::min_clock()) << "%\n";
+    cout << "\n========================================================\n";
+}
+
+void EDF_Modified::handle(Event event) {
+    RT_Common::handle(event);
+    OStream cout;
+    if(periodic() && (event & JOB_RELEASE)) {
+        // Update the priority of the thread at job releases, before _alarm->v(), so it enters the queue in the right order (called from Periodic_Thread::Xxx_Handler)
+        int task_type = (BEST_EFFORT & _priority) == BEST_EFFORT ? BEST_EFFORT : CRITICAL;
+        _last_deadline = int(elapsed());
+        _priority = int(elapsed() + _deadline) | task_type;
+        _calculate_min_frequency();
+        cout << "MIN FREQ: " << _min_frequency << '\n';
+    }
+
+    if (!periodic() && (event & FINISH)) {
+        cout << "THREAD APERIODIC FINISHED: CPU WILL BE HALTED TO PRESERVE ENERGY" << '\n';
+    }
+
+    if (((event & CHARGE) && !(event & LEAVE)) || (event & ENTER))
+        _handle_charge(event);
+
+}
 // The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
 template <typename ... Tn>
 FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
diff --git a/src/api/system_init.cc b/src/api/system_init.cc
index 9903a382a..71b620dd9 100644
--- a/src/api/system_init.cc
+++ b/src/api/system_init.cc
@@ -6,6 +6,20 @@
 
 __BEGIN_SYS
 
+
+/*
+`c` --> continue
+`q` --> quit
+`break` --> lugar de parada. Ex: break System::init() (use e abuse de tab-completion)
+`info threads` --> printa onde cada thread (cpu) está executando
+`backtrace` --> printa call stack das funções
+`thread x` --> Muda a execução atual.
+`ìnfo registers all` --> printa informações sobre todos os registradores 
+`info variables` -> list "All global and static variable names" (huge list).
+`info locals` -> list "Local variables of current stack frame" (names and values), including static variables in that function.
+`info args` -> list "Arguments of the current stack frame" (names and values).
+*/
+
 void System::init()
 {
     // These abstractions are initialized only once (by the bootstrap CPU)
@@ -13,7 +27,7 @@ void System::init()
         if(Traits<Alarm>::enabled)
             Alarm::init();
     }
-
+    
     // These abstractions are initialized by all CPUs
     if(Traits<Thread>::enabled)
         Thread::init();
diff --git a/src/api/thread.cc b/src/api/thread.cc
index 5dfa94abd..af2435fad 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -372,6 +372,14 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
     if(charge && Criterion::timed)
         _timer->restart();
 
+      
+    // Since our algorithm depends on execution time to update the frequency, we cannot run it at each preemption.
+    // Instead, it's necessary to recalculate the frequency whenever dispatch is called, be it because of preemption or because of the quantum.
+    //
+    // The function used for deciding the new frequency is quite fast, so this shouldn't be a problem.
+    if (charge && prev == next) 
+        next->criterion().handle(Criterion::CHARGE);   
+
     if(prev != next) {
         if(Criterion::dynamic) {
             prev->criterion().handle(Criterion::CHARGE | Criterion::LEAVE);
@@ -421,14 +429,14 @@ int Thread::idle()
             yield();
     }
 
+    CPU::int_disable();
+    CPU::smp_barrier();
     if(CPU::id() == CPU::BSP) {
         kout << "\n\n*** The last thread under control of EPOS has finished." << endl;
         kout << "*** EPOS is shutting down!" << endl;
+        Machine::reboot();
     }
 
-    CPU::smp_barrier();
-    Machine::reboot();
-
     return 0;
 }
 
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index a88ebe49a..0cd1d0ee7 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -17,6 +17,7 @@ void Thread::init()
     if(smp && (CPU::id() == CPU::BSP))
         IC::int_vector(IC::INT_RESCHEDULER, rescheduler);  // if an eoi handler is needed, then it was already installed at IC::init()
 
+    CPU::smp_barrier();
 
     if(smp)
         IC::enable(IC::INT_RESCHEDULER);
@@ -31,11 +32,12 @@ void Thread::init()
         Main * main = reinterpret_cast<Main *>(__epos_app_entry);
 
         new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
-    }
-
+    } else
+        Machine::delay(1000000);
 
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+    CPU::smp_barrier();
 
     // The installation of the scheduler timer handler does not need to be done after the
     // creation of threads, since the constructor won't call reschedule() which won't call
@@ -50,9 +52,8 @@ void Thread::init()
     CPU::int_disable();
 
     CPU::smp_barrier();
-
     // Transition from CPU-based locking to thread-based locking
-    if(CPU::id() == CPU::BSP)
+    if (CPU::id() == CPU::BSP)
         _not_booting = true;
 }
 
diff --git a/src/architecture/ia32/ia32_cpu_init.cc b/src/architecture/ia32/ia32_cpu_init.cc
index 9df4f8fa5..c12b236df 100644
--- a/src/architecture/ia32/ia32_cpu_init.cc
+++ b/src/architecture/ia32/ia32_cpu_init.cc
@@ -14,7 +14,7 @@ void CPU::init()
     _cpu_current_clock = System::info()->tm.cpu_clock;
     _bus_clock = System::info()->tm.bus_clock;
 
-    // Initialize the MMU
+    //Initialize the MMU
     if(CPU::id() == CPU::BSP) {
         if(Traits<MMU>::enabled)
             MMU::init();
@@ -25,6 +25,7 @@ void CPU::init()
     // Initialize the PMU	
     if(Traits<PMU>::enabled)
         PMU::init();
+
 }
 
 void CPU::smp_barrier_init(unsigned int cores) {
diff --git a/src/init/init_begin.cc b/src/init/init_begin.cc
index e49de190e..715788962 100644
--- a/src/init/init_begin.cc
+++ b/src/init/init_begin.cc
@@ -10,7 +10,10 @@ __BEGIN_SYS
 class Init_Begin
 {
 public:
-    Init_Begin() { Machine::pre_init(System::info()); }
+    Init_Begin() {
+     CPU::cores(Traits<System>::CPUS); 
+     Machine::pre_init(System::info());
+    }
 };
 
 Init_Begin init_begin;
diff --git a/src/init/init_end.cc b/src/init/init_end.cc
index cb40b94a1..52b5926fa 100644
--- a/src/init/init_end.cc
+++ b/src/init/init_end.cc
@@ -16,6 +16,8 @@ public:
     Init_End() {
         db<Init>(TRC) << "Init_End()" << endl;
 
+        CPU::smp_barrier();
+
         if(!Traits<System>::multithread) {
             CPU::int_enable();
             return;
@@ -33,6 +35,7 @@ public:
         // This barrier is particularly important, since afterwards the temporary stacks
         // and data structures established by SETUP and announced as "free memory" will indeed be
         // available to user threads.
+        CPU::smp_barrier();
 
         // Interrupts have been disabled at Thread::init() and will be reenabled by CPU::Context::load()
         // but we first reset the timer to avoid getting a time interrupt during load()
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index 00e6b5f52..3e56a99de 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -5,17 +5,19 @@
 #include <memory.h>
 #include <system.h>
 #include <process.h>
+#include <utility/ostream.h>
 
 __BEGIN_SYS
+extern OStream kout;
 
 class Init_System
 {
 private:
     static const unsigned int HEAP_SIZE = Traits<System>::HEAP_SIZE;
-
 public:
     Init_System() {
         db<Init>(TRC) << "Init_System()" << endl;
+        db<Init>(INF) << "Initializing the CPU: " << endl;
 
         CPU::smp_barrier();
 
@@ -42,20 +44,14 @@ public:
 
             db<Init>(INF) << "Initializing the machine: " << endl;
             Machine::init();
-
-            CPU::smp_barrier(); // signalizes "machine ready" to other CPUs
-
+            //Timer::init(); --> timer is already initialized by Machine::init
+            CPU::smp_barrier();
         } else {
-
-
-            db<Init>(INF) << "Initializing the CPU: " << endl;
-            CPU::init();
-
             db<Init>(INF) << "Initializing the machine: " << endl;
+            CPU::smp_barrier();
+            CPU::init();
             Timer::init();
-
         }
-
         db<Init>(INF) << "Initializing system abstractions: " << endl;
         System::init();
 
diff --git a/src/machine/pc/pc_machine_init.cc b/src/machine/pc/pc_machine_init.cc
index b8d171650..89fa82a4d 100644
--- a/src/machine/pc/pc_machine_init.cc
+++ b/src/machine/pc/pc_machine_init.cc
@@ -6,6 +6,12 @@ __BEGIN_SYS
 
 void Machine::pre_init(System_Info * si)
 {
+    // Usually BSP gets here later than other cores, so CPU::smp_barrier_init() must be idempotent
+    if(multicore) {
+        CPU::smp_barrier_init(si->bm.n_cpus);
+        CPU::smp_barrier();
+    }
+
 
     if(CPU::id() == CPU::BSP)
         Display::init();
diff --git a/src/setup/setup_legacy_pc.cc b/src/setup/setup_legacy_pc.cc
index be575a0a0..0960bd8e8 100644
--- a/src/setup/setup_legacy_pc.cc
+++ b/src/setup/setup_legacy_pc.cc
@@ -189,6 +189,8 @@ Setup::Setup(char * boot_image)
 
     }
 
+    CPU::smp_barrier(si->bm.n_cpus);
+    
     db<Setup>(INF) << "Setup::pc=" << CPU::pc() << endl;
     db<Setup>(INF) << "Setup::sp=" << CPU::sp() << endl;
     db<Setup>(INF) << "Setup::cr0=" << reinterpret_cast<void *>(CPU::cr0()) << endl;
